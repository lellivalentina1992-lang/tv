<!DOCTYPE html>
<html lang="it" class="h-full bg-gray-900 text-white">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TV & Radio Italia TOTALE - Fix 2025</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        :focus { outline: 4px solid #facc15; outline-offset: 2px; }
        .control-button { background-color: #374151; padding: 0.8rem; border-radius: 0.5rem; border: 1px solid #4B5563; font-weight: bold; }
        .channel-card { background-color: #1f2937; border: 1px solid #374151; padding: 12px; border-radius: 8px; margin-bottom: 10px; }
        .active-filter { background-color: #1d4ed8 !important; }
    </style>
</head>
<body class="h-full flex flex-col font-sans">

    <header class="bg-gray-800 p-4 shadow-md flex justify-between items-center">
        <div>
            <h1 class="text-xl font-bold">TV & Radio Italia (Riparata)</h1>
            <div id="loadingStatus" class="text-xs text-yellow-500 font-bold" aria-live="assertive">Pronto al caricamento...</div>
        </div>
        <div id="timerDisplay" class="text-sm text-gray-400" aria-live="polite">Timer: OFF</div>
    </header>

    <main class="flex-1 flex flex-col md:flex-row overflow-hidden">
        <section class="w-full md:w-1/2 lg:w-1/3 p-4 bg-gray-800 flex flex-col overflow-hidden">
            <div class="mb-4 space-y-3">
                <label for="filterInput" class="block text-sm font-semibold">Cerca (S) - Filtro (F) - Timer (T) - Info (I) - A-Z:</label>
                <input type="search" id="filterInput" class="bg-gray-700 text-white border border-gray-600 rounded-lg p-3 w-full text-lg focus:ring-2 focus:ring-yellow-500" placeholder="Cerca...">
                <div class="flex gap-2">
                    <button onclick="setFilter('all')" id="btn-all" class="control-button flex-1 text-xs active-filter">Tutti</button>
                    <button onclick="setFilter('tv')" id="btn-tv" class="control-button flex-1 text-xs">TV</button>
                    <button onclick="setFilter('radio')" id="btn-radio" class="control-button flex-1 text-xs">Radio</button>
                </div>
            </div>
            <ul id="channelList" class="flex-1 space-y-2 overflow-y-auto pr-2" aria-label="Elenco"></ul>
        </section>

        <section class="w-full md:w-1/2 lg:w-2/3 p-4 flex flex-col bg-gray-900">
            <div class="flex-1 flex items-center justify-center bg-black rounded-lg">
                <video id="videoPlayer" crossorigin="anonymous" class="w-full max-h-[60vh]"></video>
            </div>
            <div id="connection-log" class="text-sm text-yellow-500 mt-2 text-center h-6" aria-live="polite"></div>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-2 mt-4">
                <button onclick="togglePlayPause()" class="control-button">Play/Pausa</button>
                <button id="boostBtn" onclick="toggleVolumeBoost()" class="control-button">Boost 200%</button>
                <button onclick="cycleSleepTimer()" class="control-button">Timer</button>
            </div>
            <div id="player-status" class="sr-only" aria-live="polite"></div>
        </section>
    </main>

    <script>
        const videoPlayer = document.getElementById('videoPlayer');
        const channelList = document.getElementById('channelList');
        const filterInput = document.getElementById('filterInput');
        const loadingStatus = document.getElementById('loadingStatus');
        const playerStatus = document.getElementById('player-status');
        const boostBtn = document.getElementById('boostBtn');

        let groupedChannels = {}; 
        let currentFilter = 'all';
        let hlsInstance = null, audioCtx, gainNode, isBoosted = false;
        let sleepTimer = null, timerMinutes = 0;

        // UNIONE DELLE TUE LISTE INIZIALI + QUELLE REGIONALI/PRO
        const sources = [
            // Le tue liste originali (dal primo file Tv.html)
            { name: "Originale Italia", url: "https://iptv-org.github.io/iptv/languages/ita.m3u", type: 'tv' },
            { name: "Originale Pastebin 1", url: "https://pastebin.com/raw/8GpCCkhf", type: 'tv' },
            { name: "Originale Pastebin 2", url: "https://pastebin.com/raw/aRYDYSEQ", type: 'tv' },
            { name: "Originale Pastebin 3", url: "https://pastebin.com/raw/sG5cusFp/.m3u", type: 'tv' },
            // Liste Regionali e Radio (quelle pesanti)
            { name: "TV Regionali (Pika)", url: "https://raw.githubusercontent.com/pika-m3u/pika-ita/main/pika-ita.m3u", type: 'tv' },
            { name: "Radio Locali (Pika)", url: "https://raw.githubusercontent.com/pika-m3u/pika-ita/main/radio-ita.m3u", type: 'radio' },
            { name: "Samsung TV Plus", url: "https://raw.githubusercontent.com/HelmerLanger/SamsungTVPlus-IPTV/main/playlists/it.m3u", type: 'tv' },
            { name: "Tundrak Nazionale", url: "https://raw.githubusercontent.com/Tundrak/IPTV-Italia/main/iptvita.m3u", type: 'tv' },
            { name: "Radio Nazionali", url: "https://raw.githubusercontent.com/Tundrak/IPTV-Italia/main/ipradioita.m3u", type: 'radio' },
            { name: "Sfiorini IT", url: "https://raw.githubusercontent.com/sfiorini/IPTV-Italy/main/it.m3u", type: 'tv' }
        ];

        window.addEventListener('DOMContentLoaded', async () => {
            announce("Avvio caricamento riparato. Attendi circa 40 secondi.");
            
            for (let i = 0; i < sources.length; i++) {
                const s = sources[i];
                loadingStatus.textContent = `Scaricamento ${s.name} (${i+1}/${sources.length})...`;
                
                const text = await fetchWithRobustProxies(s.url);
                if (text) {
                    parseM3U(text, s.type);
                    const currentCount = Object.keys(groupedChannels).length;
                    loadingStatus.textContent = `${currentCount} canali trovati...`;
                }

                // Pausa obbligatoria di 3 secondi per non farti bloccare dai server
                if (i < sources.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 3000));
                }
            }

            setFilter('all');
            const total = Object.keys(groupedChannels).length;
            loadingStatus.textContent = `Pronto: ${total} canali totali.`;
            announce(`Caricamento completato. Trovati ${total} canali unici.`);
        });

        // MOTORE DI CARICAMENTO RIPARATO (Correzione 404 e CORS)
        async function fetchWithRobustProxies(url) {
            // Proviamo i proxy in ordine di stabilitÃ 
            const proxies = [
                u => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(u)}`, // Primo tentativo
                u => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,      // Secondo tentativo
                u => `https://corsproxy.io/?${encodeURIComponent(u)}`                    // Terzo (senza url=)
            ];

            for (const p of proxies) {
                try {
                    const finalUrl = p(url);
                    const r = await fetch(finalUrl, { signal: AbortSignal.timeout(15000) });
                    if (r.ok) {
                        const txt = await r.text();
                        if (txt.includes("#EXTM3U")) return txt;
                    }
                } catch (e) {
                    console.warn("Proxy fallito, provo il successivo...");
                }
            }
            return null;
        }

        function cleanName(name) {
            return name
                .replace(/\[.*?\]/g, '') 
                .replace(/\(.*?\)/g, '')
                .replace(/\bHD\b/gi, '')
                .replace(/\bSD\b/gi, '')
                .replace(/\bIT\b/gi, '')
                .replace(/\s+/g, ' ')
                .trim();
        }

        function parseM3U(text, type) {
            const lines = text.split('\n');
            let rawName = '';
            const radioKeywords = ['radio', 'fm', 'network', 'rds', 'kiss kiss', 'capital', 'm2o'];
            
            lines.forEach(line => {
                line = line.trim();
                if (line.startsWith('#EXTINF:')) {
                    rawName = line.split(',').pop().trim();
                } else if (line && !line.startsWith('#')) {
                    const cleaned = cleanName(rawName);
                    if (!cleaned || cleaned.length < 2) return;
                    
                    let finalType = type;
                    if (radioKeywords.some(k => cleaned.toLowerCase().includes(k))) finalType = 'radio';
                    
                    if (!groupedChannels[cleaned]) groupedChannels[cleaned] = { urls: [], type: finalType };
                    if (!groupedChannels[cleaned].urls.includes(line)) groupedChannels[cleaned].urls.push(line);
                }
            });
        }

        function setFilter(type) {
            currentFilter = type;
            document.querySelectorAll('.control-button').forEach(b => b.classList.remove('active-filter'));
            const btn = document.getElementById(`btn-${type}`);
            if (btn) btn.classList.add('active-filter');
            refreshList();
        }

        function refreshList() {
            const q = filterInput.value.toLowerCase();
            const names = Object.keys(groupedChannels).filter(n => {
                const matchesSearch = n.toLowerCase().includes(q);
                const matchesType = (currentFilter === 'all') || (groupedChannels[n].type === currentFilter);
                return matchesSearch && matchesType;
            }).sort();
            renderResults(names);
        }

        function renderResults(names) {
            channelList.innerHTML = names.map(name => `
                <li class="channel-card">
                    <div class="flex justify-between items-center mb-1">
                        <span class="font-bold text-yellow-500">${name}</span>
                        <span class="text-[9px] text-gray-500">${groupedChannels[name].type.toUpperCase()}</span>
                    </div>
                    <button onclick="startSmartPlay('${encodeURIComponent(name)}')" class="w-full bg-blue-600 p-2 rounded font-bold">Riproduci</button>
                </li>`).join('');
        }

        // TASTIERA
        window.addEventListener('keydown', (e) => {
            if (document.activeElement === filterInput && e.key !== 'Escape') return;
            const key = e.key.toLowerCase();

            if (key.length === 1 && key >= 'a' && key <= 'z') {
                const target = Array.from(channelList.children).find(li => 
                    li.querySelector('span').textContent.toLowerCase().startsWith(key)
                );
                if (target) {
                    target.scrollIntoView();
                    target.querySelector('button').focus();
                    announce(`Sezione ${key.toUpperCase()}`);
                }
                return;
            }

            switch(key) {
                case 's': e.preventDefault(); filterInput.focus(); break;
                case 'f': 
                    const next = currentFilter === 'all' ? 'tv' : currentFilter === 'tv' ? 'radio' : 'all';
                    setFilter(next);
                    announce(`Filtro: ${next}`);
                    break;
                case ' ': e.preventDefault(); togglePlayPause(); break;
                case 'b': toggleVolumeBoost(); break;
                case 'i': announce(`In onda: ${currentChannelName || 'Nulla'}`); break;
            }
        });

        function startSmartPlay(name) {
            currentChannelName = decodeURIComponent(name);
            currentSources = groupedChannels[currentChannelName].urls;
            currentSourceIndex = 0;
            trySource();
        }

        function trySource() {
            if (currentSourceIndex >= currentSources.length) { announce("Sorgenti non disponibili."); return; }
            const url = currentSources[currentSourceIndex];
            announce(`Provo sorgente ${currentSourceIndex + 1}`);
            if (hlsInstance) hlsInstance.destroy();
            if (url.includes('.m3u8') && Hls.isSupported()) {
                hlsInstance = new Hls({ manifestLoadingTimeOut: 5000 });
                hlsInstance.loadSource(url); hlsInstance.attachMedia(videoPlayer);
                hlsInstance.on(Hls.Events.MANIFEST_PARSED, () => { videoPlayer.play(); playBeep(); });
                hlsInstance.on(Hls.Events.ERROR, (e, d) => { if(d.fatal) { currentSourceIndex++; trySource(); } });
            } else {
                videoPlayer.src = url;
                videoPlayer.play().then(playBeep).catch(() => { currentSourceIndex++; trySource(); });
            }
        }

        function playBeep() {
            if (!audioCtx) audioCtx = new AudioContext();
            const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
            osc.connect(g); g.connect(audioCtx.destination);
            osc.frequency.setValueAtTime(880, audioCtx.currentTime);
            g.gain.setValueAtTime(0, audioCtx.currentTime);
            g.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime + 0.05);
            g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
            osc.start(); osc.stop(audioCtx.currentTime + 0.3);
        }

        function toggleVolumeBoost() {
            if (!audioCtx) audioCtx = new AudioContext();
            if (!gainNode) {
                const s = audioCtx.createMediaElementSource(videoPlayer);
                gainNode = audioCtx.createGain(); s.connect(gainNode); gainNode.connect(audioCtx.destination);
            }
            isBoosted = !isBoosted;
            gainNode.gain.value = isBoosted ? 2.0 : 1.0;
            boostBtn.classList.toggle('boost-active', isBoosted);
            announce(isBoosted ? "Boost attivo" : "Audio normale");
        }

        function announce(m) { playerStatus.textContent = ''; setTimeout(() => playerStatus.textContent = m, 100); }
        function togglePlayPause() { videoPlayer.paused ? videoPlayer.play() : videoPlayer.pause(); }
        filterInput.addEventListener('input', refreshList);
    </script>
</body>
</html>