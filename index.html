<!DOCTYPE html>
<html lang="it" class="h-full bg-gray-900 text-white">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TV ULTRA PRO v2026 - Feedback 2x</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://cdn.dashjs.org/latest/dash.all.min.js"></script>
    <style>
        :focus { outline: 4px solid #fbbf24; outline-offset: 2px; }
        .panel-bg { background: #1a1a1a; border: 1px solid #333; }
        .btn-action { background: #4b5563; color: white; padding: 0.7rem; border-radius: 0.6rem; text-align: center; font-weight: bold; width: 100%; }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0; }
        .channel-item { cursor: pointer; padding: 1.2rem; background: #2d3748; margin-bottom: 0.6rem; border-radius: 0.8rem; border-left: 6px solid #fbbf24; text-align: left; width: 100%; }
        .copy-btn-direct { 
            display: block; width: 100%; text-align: left; background: #1f2937; padding: 1.2rem; 
            border-radius: 0.6rem; border: 2px solid #374151; margin-bottom: 1rem; font-size: 1rem; 
        }
        .copy-btn-direct:hover, .copy-btn-direct:focus { background: #3b82f6; border-color: #fbbf24; }
    </style>
</head>
<body class="h-full flex flex-col font-sans">

    <div id="announcer" class="sr-only" aria-live="assertive"></div>

    <header class="bg-gray-800 p-4 shadow-lg flex justify-between items-center border-b border-yellow-600">
        <h1 class="text-2xl font-bold text-yellow-400">TV ULTRA PRO v2026</h1>
        <div id="status" class="text-sm font-bold text-yellow-200" aria-live="polite">Sistema Pronto</div>
    </header>

    <main class="flex-1 flex flex-col md:flex-row overflow-hidden">
        <section class="w-full md:w-1/3 lg:w-1/4 p-4 bg-gray-800 flex flex-col overflow-y-auto border-r border-gray-700">
            <h2 class="text-lg font-bold mb-3 text-yellow-400">Lista Canali</h2>
            <div class="flex gap-2 mb-4">
                <label class="flex items-center gap-2 bg-gray-900 p-3 rounded border border-gray-600 cursor-pointer flex-1">
                    <input type="checkbox" id="italianOnlyFilter" class="w-5 h-5" checked>
                    <span class="text-white text-sm font-bold">Solo canali italiani</span>
                </label>
            </div>
            <input type="search" id="searchBox" class="bg-gray-900 border border-gray-600 rounded p-4 w-full mb-3 text-white text-lg" placeholder="Cerca canale (es: RAI)" autocomplete="off">
            <div class="grid grid-cols-2 gap-2 mb-4">
                <button id="searchBtn" class="bg-blue-600 text-white font-bold py-3 rounded-xl">Cerca</button>
                <button id="loadAllBtn" class="bg-yellow-600 text-black font-bold py-3 rounded-xl">Carica Tutto</button>
            </div>
            <div id="searchProgressText" class="text-xs text-yellow-500 mb-2 font-bold" aria-live="polite"></div>
            <div id="duplicateInfo" class="text-xs text-green-400 mb-2 font-bold" aria-live="polite"></div>
            <ul id="channelList" class="flex-1 space-y-1 overflow-y-auto"></ul>
        </section>

        <section class="flex-1 p-4 bg-gray-900 flex flex-col overflow-y-auto">
            <div class="relative w-full aspect-video bg-black rounded-xl mb-6 border border-gray-800 shadow-2xl overflow-hidden">
                <video id="videoPlayer" controls playsinline crossorigin="anonymous" class="w-full h-full"></video>
            </div>
            
            <div class="grid grid-cols-2 md:grid-cols-5 gap-3 mb-8">
                <button id="fullscreenBtn" class="btn-action bg-yellow-700">Schermo Intero</button>
                <button id="volDown" class="btn-action">Volume -</button>
                <button id="volUp" class="btn-action">Volume +</button>
                <button id="muteBtn" class="btn-action">Muto (M)</button>
                <button id="copyDebugBtn" class="btn-action bg-gray-700">Copia Log</button>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                <div class="p-5 rounded-xl panel-bg border-yellow-600 border-2">
                    <h2 class="text-xl font-bold text-yellow-500 mb-4">Registrazione</h2>
                    <input type="url" id="serverUrl" class="w-full bg-black p-3 mb-4 rounded border border-gray-700 text-white" placeholder="URL Server">
                    <input type="text" id="serverPin" class="w-full bg-black p-3 mb-4 rounded border border-gray-700 text-white" placeholder="PIN">
                    <div class="flex gap-3 mb-4">
                        <select id="regHour" class="flex-1 bg-black p-3 rounded border border-gray-700 text-white"></select>
                        <select id="regMin" class="flex-1 bg-black p-3 rounded border border-gray-700 text-white"></select>
                    </div>
                    <button id="confirmRecordBtn" class="w-full bg-yellow-600 text-black font-bold py-4 rounded-xl">Programma Registrazione</button>
                </div>

                <div class="p-5 rounded-xl panel-bg border-gray-700 border">
                    <h2 class="text-xl font-bold text-yellow-500 mb-4">Copia Link Rapido</h2>
                    <div id="directLinksArea" class="flex flex-col max-h-[400px] overflow-y-auto"></div>
                </div>
            </div>
        </section>
    </main>

    <script>
        const ALL_LISTS = [
            { name: "Lista Personale", url: "https://raw.githubusercontent.com/lellivalentina1992-lang/tv/refs/heads/main/lista_personale.m3u" },
            { name: "Tundrak TV", url: "https://raw.githubusercontent.com/Tundrak/IPTV-Italia/main/iptvita.m3u" },
            { name: "Radio ITA", url: "https://raw.githubusercontent.com/Tundrak/IPTV-Italia/main/ipradioita.m3u" },
            { name: "TV Italia Fulgione", url: "http://davidefulgione.it/tv.m3u" },
            { name: "Tivu.m3u Fulgione", url: "http://www.davidefulgione.it/tivu.m3u" },
            { name: "Dario-S Italia", url: "https://raw.githubusercontent.com/dario-s/italia-iptv/master/italia.m3u" },
            { name: "Pluto TV", url: "https://raw.githubusercontent.com/TheWorldOfIPTV/WorldOfIPTV/master/Lists/PlutoTV/IT.m3u" },
            { name: "Rakuten TV", url: "https://raw.githubusercontent.com/TheWorldOfIPTV/WorldOfIPTV/master/Lists/RakutenTV/IT.m3u" },
            { name: "Plex TV", url: "https://raw.githubusercontent.com/TheWorldOfIPTV/WorldOfIPTV/master/Lists/Plex/IT.m3u" },
            { name: "Pura TV", url: "https://raw.githubusercontent.com/PuraTV/PuraTV.github.io/master/m3u8/it.m3u" },
            { name: "IPTV-Org Italia", url: "https://iptv-org.github.io/iptv/languages/ita.m3u" },
            { name: "Free-TV", url: "https://raw.githubusercontent.com/Free-TV/IPTV/master/playlist/it.m3u" },
            { name: "In The Mix", url: "http://inthemix.altervista.org/tv.m3u" },
            { name: "TivuStream", url: "https://tivustream.website/urls/listm3u" },
            { name: "Samsung Plus", url: "https://raw.githubusercontent.com/TheWorldOfIPTV/WorldOfIPTV/master/Lists/SamsungTVPlus/IT.m3u" },
            { name: "DF-Fulgi GitHub", url: "https://raw.githubusercontent.com/df-fulgi/iptv/master/italy.m3u" },
            { name: "Tvditutto", url: "https://raw.githubusercontent.com/Tvditutto/z-m3u/main/italy.m3u" },
            { name: "PandaSat", url: "http://www.pandasat.info/iptv/kodi" }
        ];

        const EPG_URL = "https://epg.zappr.stream/gui.xml";
        let epgDoc = null;
        let allChannels = [];
        let hlsPlayer = null, dashPlayer = null, sessionLogs = [];
        const video = document.getElementById('videoPlayer');

        const hS = document.getElementById('regHour'), mS = document.getElementById('regMin');
        for(let i=0; i<24; i++) hS.add(new Option(i.toString().padStart(2,'0'), i.toString().padStart(2,'0')));
        for(let i=0; i<60; i+=5) mS.add(new Option(i.toString().padStart(2,'0'), i.toString().padStart(2,'0')));

        function logEvent(msg) { 
            sessionLogs.push(`[${new Date().toLocaleTimeString()}] ${msg}`); 
            console.log(msg); 
        }
        
        function comunica(t) { 
            logEvent(t); 
            const a = document.getElementById('announcer'); 
            a.textContent = ""; 
            setTimeout(() => { a.textContent = t; }, 50);
        }

        async function safeCopy(text) {
            try {
                if (navigator.clipboard && window.isSecureContext) {
                    await navigator.clipboard.writeText(text);
                    return true;
                }
            } catch (e) {
                // fallthrough
            }

            try {
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.setAttribute('readonly', '');
                ta.style.position = 'fixed';
                ta.style.left = '-9999px';
                document.body.appendChild(ta);
                ta.select();
                const success = document.execCommand('copy');
                document.body.removeChild(ta);
                if (success) return true;
            } catch (e) {
                // fail
            }

            comunica("Copia manuale richiesta: impossibile copiare automaticamente.");
            return false;
        }

        function normalize(s) { 
            return s.toLowerCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .replace(/[^a-z0-9]/g, ''); 
        }

        function smartIncludes(str, query) {
            return normalize(str).includes(normalize(query));
        }

        function isItalianChannel(channelName, url) {
            const name = channelName.toLowerCase();
            const urlLower = url.toLowerCase();
            
            // Pattern canali italiani espliciti
            const italianPatterns = [
                // Canali TV principali
                'rai', 'mediaset', 'la7', 'tv8', 'nove', 'real time', 'dmax',
                'canale 5', 'italia 1', 'rete 4', 'iris', 'twentyseven', 'cine34',
                'focus', 'giallo', 'top crime', 'spike', 'paramount', 'super!',
                // Canali regionali
                'tele', 'telepace', 'tv2000', 'byoblu', 'radio', 'tgcom',
                // Pattern geografici
                'italia', 'italian', 'toscana', 'lombardia', 'lazio', 'veneto',
                'sicilia', 'sardegna', 'piemonte', 'emilia', 'campania', 'puglia',
                'calabria', 'liguria', 'marche', 'umbria', 'abruzzo', 'molise',
                'basilicata', 'friuli', 'trentino', 'valle d\'aosta',
                // Città
                'roma', 'milano', 'napoli', 'torino', 'palermo', 'genova',
                'bologna', 'firenze', 'bari', 'catania', 'venezia', 'verona',
                'padova', 'trieste', 'brescia', 'parma', 'modena', 'reggio',
                // Sport italiani
                'serie a', 'serie b', 'calcio', 'italia', 'azzurri',
                //Musica italiana
                'rtl 102.5', 'radio italia', 'radio 105', 'deejay', 'rds',
                'virgin radio', 'monte carlo', 'capital', 'subasio',
                // Altri indicatori comuni
                'italiano', 'ita', 'italy',
                // Pattern TV locali comuni
                'studio', 'antenna', 'trc', 'tvr', 'telelombardia', 'telenorba',
                'videolina', 'canale', 'telecolor', 'telereporter', 'grp',
                'nuovarete', 'telelibertà', 'teleboario', 'espansione',
                // Pattern generici TV italiana
                'channel', 'news', 'sport', 'music', 'movie', 'cinema'
            ];
            
            // Controlla se il nome contiene pattern italiani
            for (let pattern of italianPatterns) {
                if (name.includes(pattern)) return true;
            }
            
            // Controlla URL per indicatori italiani
            if (urlLower.includes('/it.m3u') || 
                urlLower.includes('/ita.m3u') ||
                urlLower.includes('/italia') ||
                urlLower.includes('italian') ||
                urlLower.includes('italy') ||
                urlLower.includes('/it/') ||
                urlLower.includes('_it.') ||
                urlLower.includes('-it.')) {
                return true;
            }
            
            // Controlla se viene da liste italiane note
            const italianLists = [
                'tundrak', 'fulgione', 'dario-s', 'pandasat', 
                'tivustream', 'df-fulgi', 'tvditutto'
            ];
            
            for (let listName of italianLists) {
                if (urlLower.includes(listName)) return true;
            }
            
            return false;
        }

        function findDuplicates(channels) {
            const groups = {};
            
            channels.forEach(ch => {
                const normalized = normalize(ch.name);
                if (!groups[normalized]) {
                    groups[normalized] = [];
                }
                groups[normalized].push(ch);
            });
            
            return groups;
        }

        async function loadEPG() {
            try {
                const r = await fetch(EPG_URL);
                const txt = await r.text();
                const parser = new DOMParser();
                epgDoc = parser.parseFromString(txt, 'text/xml');
                logEvent("EPG caricato.");
            } catch { 
                logEvent("EPG non disponibile."); 
            }
        }

        function getProgramInfo(channelName) {
            if (!epgDoc) return null;
            const now = Date.now();
            const channels = epgDoc.querySelectorAll('channel');
            for (let ch of channels) {
                const dispName = ch.querySelector('display-name')?.textContent || '';
                if (!smartIncludes(dispName, channelName)) continue;
                const cid = ch.getAttribute('id');
                const progs = epgDoc.querySelectorAll(`programme[channel="${cid}"]`);
                for (let p of progs) {
                    const start = new Date(p.getAttribute('start').replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2}).*/, '$1-$2-$3T$4:$5:$6')).getTime();
                    const stop = new Date(p.getAttribute('stop').replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2}).*/, '$1-$2-$3T$4:$5:$6')).getTime();
                    if (now >= start && now <= stop) {
                        const title = p.querySelector('title')?.textContent || 'Senza titolo';
                        return title;
                    }
                }
            }
            return null;
        }

        function parseM3U(content, source) {
            const lines = content.split('\n');
            const result = [];
            let currentName = null;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith('#EXTINF')) {
                    const match = line.match(/,(.*)$/);
                    currentName = match ? match[1].trim() : 'Sconosciuto';
                } else if (line && !line.startsWith('#') && currentName) {
                    result.push({ name: currentName, url: line, source });
                    currentName = null;
                }
            }
            return result;
        }

        async function searchInList(listObj, query) {
            try {
                const r = await fetch(listObj.url);
                if (!r.ok) return [];
                const txt = await r.text();
                const parsed = parseM3U(txt, listObj.name);
                return parsed.filter(c => smartIncludes(c.name, query));
            } catch {
                return [];
            }
        }

        async function searchSpecific() {
            const query = document.getElementById('searchBox').value.trim();
            if (!query) {
                comunica("Inserisci un termine di ricerca.");
                return;
            }
            
            const italianOnly = document.getElementById('italianOnlyFilter').checked;
            
            allChannels = [];
            let totalBeforeFilter = 0;
            document.getElementById('channelList').innerHTML = "";
            document.getElementById('directLinksArea').innerHTML = "";
            document.getElementById('duplicateInfo').textContent = "";
            comunica(`Ricerca di "${query}" in 18 liste${italianOnly ? ' (solo italiani)' : ''}`);

            let completed = 0;
            const prog = document.getElementById('searchProgressText');

            const promises = ALL_LISTS.map(async (list) => {
                try {
                    const results = await searchInList(list, query);
                    totalBeforeFilter += results.length;
                    
                    // Applica filtro italiano se attivo
                    const filtered = italianOnly ? 
                        results.filter(c => isItalianChannel(c.name, c.url)) : 
                        results;
                    allChannels.push(...filtered);
                    completed++;
                    prog.textContent = `${completed}/${ALL_LISTS.length} liste completate`;
                    return filtered;
                } catch {
                    completed++;
                    prog.textContent = `${completed}/${ALL_LISTS.length} liste completate`;
                    return [];
                }
            });

            await Promise.all(promises);

            // Rileva doppioni
            const duplicateGroups = findDuplicates(allChannels);
            const uniqueNames = Object.keys(duplicateGroups);
            
            // Conta doppioni
            let totalDuplicates = 0;
            Object.values(duplicateGroups).forEach(group => {
                if (group.length > 1) totalDuplicates += group.length - 1;
            });
            
            // Statistiche filtro
            const excludedCount = totalBeforeFilter - allChannels.length;
            let statsMessage = `Trovati ${uniqueNames.length} canali per "${query}" da ${allChannels.length} fonti.`;
            
            if (italianOnly && excludedCount > 0) {
                statsMessage += ` Esclusi ${excludedCount} non italiani.`;
            }
            
            comunica(statsMessage);
            
            // Info doppioni
            if (totalDuplicates > 0) {
                document.getElementById('duplicateInfo').textContent = 
                    `${totalDuplicates} varianti trovate.`;
            } else if (italianOnly && excludedCount > 0) {
                document.getElementById('duplicateInfo').textContent = 
                    `Filtro italiano: ${excludedCount} canali esclusi.`;
            }

            if (uniqueNames.length === 0) {
                document.getElementById('channelList').innerHTML = '<li style="padding: 1rem; color: #fbbf24;">Nessun canale trovato. Prova a disattivare il filtro italiano o cerca un altro termine.</li>';
            } else {
                renderChannelList(duplicateGroups);
            }
            
            renderDirectLinks();
        }
        
        async function loadAllChannels() {
            const italianOnly = document.getElementById('italianOnlyFilter').checked;
            
            allChannels = [];
            let totalBeforeFilter = 0;
            document.getElementById('channelList').innerHTML = "";
            document.getElementById('directLinksArea').innerHTML = "";
            document.getElementById('duplicateInfo').textContent = "";
            comunica(`Caricamento di TUTTI i canali da 18 liste${italianOnly ? ' (solo italiani)' : ''}`);

            let completed = 0;
            const prog = document.getElementById('searchProgressText');

            const promises = ALL_LISTS.map(async (list) => {
                try {
                    const r = await fetch(list.url);
                    if (!r.ok) return [];
                    const txt = await r.text();
                    const parsed = parseM3U(txt, list.name);
                    totalBeforeFilter += parsed.length;
                    
                    // Applica filtro italiano se attivo
                    const filtered = italianOnly ? 
                        parsed.filter(c => isItalianChannel(c.name, c.url)) : 
                        parsed;
                    allChannels.push(...filtered);
                    completed++;
                    prog.textContent = `${completed}/${ALL_LISTS.length} liste completate`;
                    return filtered;
                } catch {
                    completed++;
                    prog.textContent = `${completed}/${ALL_LISTS.length} liste completate`;
                    return [];
                }
            });

            await Promise.all(promises);

            // Rileva doppioni
            const duplicateGroups = findDuplicates(allChannels);
            const uniqueNames = Object.keys(duplicateGroups);
            
            // Conta doppioni
            let totalDuplicates = 0;
            Object.values(duplicateGroups).forEach(group => {
                if (group.length > 1) totalDuplicates += group.length - 1;
            });
            
            // Statistiche filtro
            const excludedCount = totalBeforeFilter - allChannels.length;
            let statsMessage = `Caricati ${uniqueNames.length} canali univoci da ${allChannels.length} fonti.`;
            
            if (italianOnly && excludedCount > 0) {
                statsMessage += ` Esclusi ${excludedCount} non italiani.`;
            }
            
            comunica(statsMessage);
            
            // Info doppioni
            if (totalDuplicates > 0) {
                document.getElementById('duplicateInfo').textContent = 
                    `${totalDuplicates} varianti disponibili. Usa la ricerca per filtrare.`;
            } else if (italianOnly && excludedCount > 0) {
                document.getElementById('duplicateInfo').textContent = 
                    `Filtro italiano: ${excludedCount} canali esclusi.`;
            }

            renderChannelList(duplicateGroups);
            renderDirectLinks();
        }

        function renderChannelList(duplicateGroups) {
            const list = document.getElementById('channelList');
            list.innerHTML = "";
            
            // Ordina i canali alfabeticamente
            const sortedNames = Object.keys(duplicateGroups).sort();
            
            sortedNames.forEach(normalizedName => {
                const group = duplicateGroups[normalizedName];
                const displayName = group[0].name; // Usa il primo nome originale
                const count = group.length;
                
                const li = document.createElement('li');
                const btn = document.createElement('button');
                btn.className = "channel-item";
                
                // Mostra il numero corretto di fonti
                if (count > 1) {
                    btn.innerHTML = `<strong>${displayName}</strong><br><small>${count} ${count === 1 ? 'fonte' : 'fonti'}: ${group.map(g => g.source).join(', ')}</small>`;
                } else {
                    btn.innerHTML = `<strong>${displayName}</strong><br><small>${group[0].source}</small>`;
                }
                
                btn.onclick = () => autoPlay(displayName);
                li.appendChild(btn);
                list.appendChild(li);
            });
        }

        function renderDirectLinks() {
            const area = document.getElementById('directLinksArea'); 
            area.innerHTML = "";
            allChannels.forEach(c => {
                const fmt = c.url.includes('.mpd') ? 'DASH' : (c.url.includes('.m3u8') ? 'HLS' : 'DIRETTO');
                const btn = document.createElement('button'); 
                btn.className = "copy-btn-direct";
                btn.innerHTML = `<strong>${c.name}</strong> - ${c.source}<br><small>Formato: ${fmt}</small>`;
                btn.onclick = async () => { 
                    const ok = await safeCopy(c.url); 
                    if (ok) comunica(`Copiato ${c.name} - ${fmt}`); 
                };
                area.appendChild(btn);
            });
        }

        async function autoPlay(name) {
            const sources = allChannels.filter(c => smartIncludes(c.name, name));
            
            if (sources.length === 0) {
                comunica(`Nessuna fonte disponibile per ${name}.`);
                return;
            }
            
            comunica(`Avvio ${name}. Tentativo su ${sources.length} ${sources.length === 1 ? 'fonte' : 'fonti'}.`);
            
            for (let i = 0; i < sources.length; i++) {
                const s = sources[i];
                document.getElementById('status').textContent = `Prova ${i+1}/${sources.length}: ${s.source}`;
                
                const ok = await new Promise(res => {
                    let settled = false;
                    const timers = [];

                    const cleanup = () => {
                        timers.forEach(clearTimeout);
                        video.removeEventListener('playing', onPlaying);
                        video.removeEventListener('canplay', onSoftReady);
                        video.removeEventListener('loadedmetadata', onSoftReady);
                        video.removeEventListener('error', onVideoError);
                        if (hlsPlayer && hlsPlayer.off) hlsPlayer.off(Hls.Events.ERROR, onHlsError);
                        if (dashPlayer && dashPlayer.off) dashPlayer.off('error', onDashError);
                    };

                    const finish = (val) => {
                        if (settled) return;
                        settled = true;
                        cleanup();
                        res(val);
                    };

                    const onPlaying = () => finish(true);
                    const onSoftReady = () => { video.play().catch(()=>{}); };
                    const onVideoError = () => finish(false);

                    const onHlsError = (event, data) => {
                        if (data && data.fatal) finish(false);
                    };

                    const onDashError = () => finish(false);

                    try { 
                        if (hlsPlayer) { 
                            hlsPlayer.destroy(); 
                            hlsPlayer = null; 
                        } 
                    } catch(e) {}
                    
                    try {
                        if (dashPlayer) {
                            if (dashPlayer.reset) dashPlayer.reset();
                            else if (dashPlayer.destroy) dashPlayer.destroy();
                            dashPlayer = null;
                        }
                    } catch(e) {}

                    video.src = "";

                    video.addEventListener('playing', onPlaying, { once: true });
                    video.addEventListener('canplay', onSoftReady);
                    video.addEventListener('loadedmetadata', onSoftReady);
                    video.addEventListener('error', onVideoError, { once: true });

                    if (s.url.includes('.mpd')) {
                        dashPlayer = dashjs.MediaPlayer().create();
                        if (dashPlayer.on) dashPlayer.on('error', onDashError);
                        dashPlayer.initialize(video, s.url, true);
                    } else if (s.url.includes('.m3u8') && Hls.isSupported()) {
                        hlsPlayer = new Hls();
                        hlsPlayer.on(Hls.Events.ERROR, onHlsError);
                        hlsPlayer.loadSource(s.url);
                        hlsPlayer.attachMedia(video);
                        hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => video.play().catch(()=>{}));
                    } else {
                        video.src = s.url;
                        video.play().catch(()=>{});
                    }

                    [8000, 12000, 20000].forEach((ms, idx, arr) => {
                        timers.push(setTimeout(() => {
                            if (settled) return;
                            if (idx === arr.length - 1) finish(false);
                        }, ms));
                    });
                });
                
                if (ok) {
                    window.activeUrl = s.url; 
                    window.activeName = s.name;
                    const prog = getProgramInfo(name);
                    comunica(`In onda ${name} da ${s.source}. ${prog ? 'Programma: ' + prog : ''}`);
                    document.getElementById('status').textContent = `${name} - ${s.source}`;
                    return;
                }
            }
            
            comunica(`${name}: tutte le ${sources.length} ${sources.length === 1 ? 'fonte non risponde' : 'fonti non rispondono'}.`);
            document.getElementById('status').textContent = 'Errore riproduzione';
        }

        window.addEventListener('keydown', e => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
            if (e.key.toLowerCase() === 'm') { 
                e.preventDefault(); 
                video.muted = !video.muted; 
                comunica(video.muted ? "Muto" : "Audio attivo"); 
            }
            if (e.key === 'ArrowUp') { 
                e.preventDefault(); 
                video.volume = Math.min(1, video.volume + 0.1); 
                comunica(`Volume ${Math.round(video.volume*100)}%`); 
            }
            if (e.key === 'ArrowDown') { 
                e.preventDefault(); 
                video.volume = Math.max(0, video.volume - 0.1); 
                comunica(`Volume ${Math.round(video.volume*100)}%`); 
            }
        });

        document.getElementById('searchBtn').onclick = searchSpecific;
        document.getElementById('loadAllBtn').onclick = loadAllChannels;
        document.getElementById('searchBox').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                searchSpecific();
            }
        });
        document.getElementById('italianOnlyFilter').addEventListener('change', () => {
            if (allChannels.length > 0) {
                const hasSearchTerm = document.getElementById('searchBox').value.trim();
                if (hasSearchTerm) {
                    searchSpecific(); // Ricerca con nuovo filtro
                } else {
                    loadAllChannels(); // Ricarica tutto con nuovo filtro
                }
            }
        });
        document.getElementById('volUp').onclick = () => { 
            video.volume = Math.min(1, video.volume + 0.1); 
            comunica(`Volume ${Math.round(video.volume*100)}%`); 
        };
        document.getElementById('volDown').onclick = () => { 
            video.volume = Math.max(0, video.volume - 0.1); 
            comunica(`Volume ${Math.round(video.volume*100)}%`); 
        };
        document.getElementById('muteBtn').onclick = () => { 
            video.muted = !video.muted; 
            comunica(video.muted ? "Muto" : "Audio attivo"); 
        };
        document.getElementById('fullscreenBtn').onclick = () => video.requestFullscreen?.() || video.webkitRequestFullscreen?.();
        document.getElementById('copyDebugBtn').onclick = async () => { 
            const ok = await safeCopy(sessionLogs.join('\n')); 
            if (ok) comunica("Log copiati."); 
        };
        document.getElementById('confirmRecordBtn').onclick = async () => {
            const sUrl = document.getElementById('serverUrl').value.trim();
            if(!sUrl || !window.activeUrl) return comunica("Dati mancanti.");
            const payload = { 
                url: window.activeUrl, 
                channelName: window.activeName, 
                time: `${hS.value}:${mS.value}`, 
                duration: "60" 
            };
            const pin = document.getElementById('serverPin').value.trim();
            if(pin) payload.pin = pin;
            try { 
                const r = await fetch(`${sUrl}/api/record-scheduled`, { 
                    method:'POST', 
                    headers:{'Content-Type':'application/json'}, 
                    body:JSON.stringify(payload) 
                }); 
                comunica(r.ok ? "Registrato!" : "Errore"); 
            } catch { 
                comunica("Server off"); 
            }
        };

        loadEPG();
    </script>
</body>
</html>